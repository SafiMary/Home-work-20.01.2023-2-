#include <iostream>
#include <string>
#include <vector>
#include <stdio.h>
#include <windows.h>
//Пример агрегации, где класс вода не зависит от класса аквариум, может быть использован в других классах
//В классе аквариум, используется лишь объект класса вода
//Плюс агрегации:
//класс вода может существовать независимо от класса аквариум
//класс вода не уничтожится при уничтожении класса аквариум
//агрегация иногда удобно -заменяет наследование
class Water {   
public:
	std::string getQuality() {
		return _quality;
	}

private:
	std::string _quality = " high quality water";

};

//Пример композиции, где класс рыба не может существовать без класса аквариум
//если уничтожить класс аквариум- уничтожится и класс рыба
// Плюсы композиции:
//простота в изменении и адаптации кода в дальнейшем
//Минусы композиции:
//уничтожаются сразу оба класса и дочерний и родительский
class Aquarium {
public:
	void swim() {//метод где идет взаимодействие классов аквариум и рыба
	 fish.swim();
	}

	void fill() {//метод где идет взаимодействие классов аквариум и рыба //агрегация
		std::cout << "Filled the aquarium " << water.getQuality();

	}
private:
	class Fish {//композиция
	public:
		void swim() {
			std::cout << "I'm swimming " << std::endl;
		}

	};
	Fish fish;//композиция
	Water water;//агрегация
};




int main() {
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	Aquarium a;
	a.swim();//аквариум использует метод класса рыба
	a.fill();//аквариум использует метод public метод класса вода, тк у него есть объект класса вода

}